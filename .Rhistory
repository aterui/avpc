mod <- stats::model.matrix(m) %>% as_tibble()
v_var_name <- colnames(mod)
# initial check -----------------------------------------------------------
## validate u input
if (length(u) > 1) stop("u must be a single variable")
if (!any(u %in% v_var_name)) {
stop(paste("invalid variable input u. available variable names:",
paste(v_var_name, collapse = ", ")))
}
## validate v input
if (is.null(v)) {
v <- v_var_name[!(v_var_name %in% c("(Intercept)", u))]
} else {
if (!all(v %in% v_var_name)) {
stop(paste("invalid variable input v. available variable names:",
paste(v_var_name, collapse = ", ")))
}
}
# get pairs for u and v ---------------------------------------------------
## frame for v variables
m_x1 <- m_x2 <- mod %>%
dplyr::select(dplyr::all_of(v))
m_x <- m_x1 %>%
dplyr::mutate(id = as.numeric(rownames(m_x1)))
## mahalanobis distance for a set of v variables
m_cov <- stats::cov(m_x1)
m_dist <- apply(m_x1, 1, function(row_i) stats::mahalanobis(m_x2, row_i, m_cov))
df_v <-  dplyr::tibble(sq_distance = c(m_dist),
row_id = rep(seq_len(nrow(m_dist)),
times = ncol(m_dist)),
col_id = rep(seq_len(ncol(m_dist)),
each = nrow(m_dist))) %>%
dplyr::mutate(weight = 1 / (1 + .data$sq_distance))
## combine with input u
m_u <- mod %>%
dplyr::select(dplyr::all_of(u)) %>%
dplyr::rename(u_input = dplyr::all_of(u)) %>%
dplyr::mutate(id = as.numeric(rownames(mod)))
df_uv <- df_v %>%
dplyr::left_join(m_u, by = c("row_id" = "id")) %>%
dplyr::rename(u1 = .data$u_input) %>%
dplyr::left_join(m_u, by = c("col_id" = "id")) %>%
dplyr::rename(u2 = .data$u_input) %>%
dplyr::mutate(sign = ifelse(u2 - u1 >= 0, 1, -1)) %>%
dplyr::left_join(m_x, by = c("row_id" = "id"), suffix = c("_v1", "_v2")) %>%
dplyr::left_join(m_x, by = c("col_id" = "id"), suffix = c("_v1", "_v2"))
# average predictive comparison -------------------------------------------
## input u and other variables v (note: v is v1 irrespective of input u)
u1 <- df_uv %>% dplyr::pull(.data$u1)
u2 <- df_uv %>% dplyr::pull(.data$u2)
df_v1 <- df_uv %>% dplyr::summarize(dplyr::across(dplyr::ends_with("v1")))
## input low
df_uv1 <- dplyr::tibble(u1 = u1, df_v1)
colnames(df_uv1) <- c(u, v)
df_uv1 <- dplyr::tibble("(Intercept)" = 1, df_uv1)
## input high
df_uv2 <- dplyr::tibble(u2 = u2, df_v1)
colnames(df_uv2) <- c(u, v)
df_uv2 <- dplyr::tibble("(Intercept)" = 1, df_uv2)
## get link function from the model object if var_transform "null"
if (is.null(var_transform)) {
model_family <- stats::family(m)
var_transform <- model_family$link
}
if (!any(var_transform %in% c("log", "log10", "logit", "identity"))) {
stop("var_transform must be either log, log10, logit or identity")
}
## get coefficients
if (any(class(m) %in% c("lm", "rlm", "glm"))) {
v_b <- m$coefficients
} else {
v_b <- m@beta
names(v_beta) <- v_var_name
}
v_var_id <- match(names(v_b), colnames(df_uv1)) %>%
stats::na.omit() %>%
c()
v_beta <- v_b[names(v_b) %in% c("(Intercept)", u, v)] %>%
data.matrix()
## matrix of input and other variables
m_uv1 <- data.matrix(df_uv1[, v_var_id])
m_uv2 <- data.matrix(df_uv2[, v_var_id])
if (any(rownames(v_beta) != colnames(m_uv1))) {
stop("error in matrix organization")
}
if (any(rownames(v_beta) != colnames(m_uv2))) {
stop("error in matrix organization")
}
var_transform <- NULL
# inverse logit function --------------------------------------------------
ilogit <- function(x) {
1 / (1 + exp(-x))
}
# model extraction --------------------------------------------------------
## validate model class
if (!any(class(m) %in% c("lm", "rlm", "glm", "lmerMod"))) {
stop("the provided model class is not supported")
}
mod <- stats::model.matrix(m) %>% as_tibble()
v_var_name <- colnames(mod)
# initial check -----------------------------------------------------------
## validate u input
if (length(u) > 1) stop("u must be a single variable")
if (!any(u %in% v_var_name)) {
stop(paste("invalid variable input u. available variable names:",
paste(v_var_name, collapse = ", ")))
}
## validate v input
if (is.null(v)) {
v <- v_var_name[!(v_var_name %in% c("(Intercept)", u))]
} else {
if (!all(v %in% v_var_name)) {
stop(paste("invalid variable input v. available variable names:",
paste(v_var_name, collapse = ", ")))
}
}
# get pairs for u and v ---------------------------------------------------
## frame for v variables
m_x1 <- m_x2 <- mod %>%
dplyr::select(dplyr::all_of(v))
m_x <- m_x1 %>%
dplyr::mutate(id = as.numeric(rownames(m_x1)))
## mahalanobis distance for a set of v variables
m_cov <- stats::cov(m_x1)
m_dist <- apply(m_x1, 1, function(row_i) stats::mahalanobis(m_x2, row_i, m_cov))
df_v <-  dplyr::tibble(sq_distance = c(m_dist),
row_id = rep(seq_len(nrow(m_dist)),
times = ncol(m_dist)),
col_id = rep(seq_len(ncol(m_dist)),
each = nrow(m_dist))) %>%
dplyr::mutate(weight = 1 / (1 + .data$sq_distance))
## combine with input u
m_u <- mod %>%
dplyr::select(dplyr::all_of(u)) %>%
dplyr::rename(u_input = dplyr::all_of(u)) %>%
dplyr::mutate(id = as.numeric(rownames(mod)))
df_uv <- df_v %>%
dplyr::left_join(m_u, by = c("row_id" = "id")) %>%
dplyr::rename(u1 = .data$u_input) %>%
dplyr::left_join(m_u, by = c("col_id" = "id")) %>%
dplyr::rename(u2 = .data$u_input) %>%
dplyr::mutate(sign = ifelse(u2 - u1 >= 0, 1, -1)) %>%
dplyr::left_join(m_x, by = c("row_id" = "id"), suffix = c("_v1", "_v2")) %>%
dplyr::left_join(m_x, by = c("col_id" = "id"), suffix = c("_v1", "_v2"))
# average predictive comparison -------------------------------------------
## input u and other variables v (note: v is v1 irrespective of input u)
u1 <- df_uv %>% dplyr::pull(.data$u1)
u2 <- df_uv %>% dplyr::pull(.data$u2)
df_v1 <- df_uv %>% dplyr::summarize(dplyr::across(dplyr::ends_with("v1")))
## input low
df_uv1 <- dplyr::tibble(u1 = u1, df_v1)
colnames(df_uv1) <- c(u, v)
df_uv1 <- dplyr::tibble("(Intercept)" = 1, df_uv1)
## input high
df_uv2 <- dplyr::tibble(u2 = u2, df_v1)
colnames(df_uv2) <- c(u, v)
df_uv2 <- dplyr::tibble("(Intercept)" = 1, df_uv2)
## get link function from the model object if var_transform "null"
if (is.null(var_transform)) {
model_family <- stats::family(m)
var_transform <- model_family$link
}
if (!any(var_transform %in% c("log", "log10", "logit", "identity"))) {
stop("var_transform must be either log, log10, logit or identity")
}
## get coefficients
if (any(class(m) %in% c("lm", "rlm", "glm"))) {
v_b <- m$coefficients
} else {
v_b <- m@beta
names(v_beta) <- v_var_name
}
v_var_id <- match(names(v_b), colnames(df_uv1)) %>%
stats::na.omit() %>%
c()
v_beta <- v_b[names(v_b) %in% c("(Intercept)", u, v)] %>%
data.matrix()
## matrix of input and other variables
m_uv1 <- data.matrix(df_uv1[, v_var_id])
m_uv2 <- data.matrix(df_uv2[, v_var_id])
if (any(rownames(v_beta) != colnames(m_uv1))) {
stop("error in matrix organization")
}
if (any(rownames(v_beta) != colnames(m_uv2))) {
stop("error in matrix organization")
}
# inverse logit function --------------------------------------------------
ilogit <- function(x) {
1 / (1 + exp(-x))
}
# model extraction --------------------------------------------------------
## validate model class
if (!any(class(m) %in% c("lm", "rlm", "glm", "lmerMod"))) {
stop("the provided model class is not supported")
}
mod <- stats::model.matrix(m) %>% as_tibble()
v_var_name <- colnames(mod)
# initial check -----------------------------------------------------------
## validate u input
if (length(u) > 1) stop("u must be a single variable")
if (!any(u %in% v_var_name)) {
stop(paste("invalid variable input u. available variable names:",
paste(v_var_name, collapse = ", ")))
}
## validate v input
if (is.null(v)) {
v <- v_var_name[!(v_var_name %in% c("(Intercept)", u))]
} else {
if (!all(v %in% v_var_name)) {
stop(paste("invalid variable input v. available variable names:",
paste(v_var_name, collapse = ", ")))
}
}
# get pairs for u and v ---------------------------------------------------
## frame for v variables
m_x1 <- m_x2 <- mod %>%
dplyr::select(dplyr::all_of(v))
m_x <- m_x1 %>%
dplyr::mutate(id = as.numeric(rownames(m_x1)))
## mahalanobis distance for a set of v variables
m_cov <- stats::cov(m_x1)
m_dist <- apply(m_x1, 1, function(row_i) stats::mahalanobis(m_x2, row_i, m_cov))
df_v <-  dplyr::tibble(sq_distance = c(m_dist),
row_id = rep(seq_len(nrow(m_dist)),
times = ncol(m_dist)),
col_id = rep(seq_len(ncol(m_dist)),
each = nrow(m_dist))) %>%
dplyr::mutate(weight = 1 / (1 + .data$sq_distance))
## combine with input u
m_u <- mod %>%
dplyr::select(dplyr::all_of(u)) %>%
dplyr::rename(u_input = dplyr::all_of(u)) %>%
dplyr::mutate(id = as.numeric(rownames(mod)))
df_uv <- df_v %>%
dplyr::left_join(m_u, by = c("row_id" = "id")) %>%
dplyr::rename(u1 = .data$u_input) %>%
dplyr::left_join(m_u, by = c("col_id" = "id")) %>%
dplyr::rename(u2 = .data$u_input) %>%
dplyr::mutate(sign = ifelse(u2 - u1 >= 0, 1, -1)) %>%
dplyr::left_join(m_x, by = c("row_id" = "id"), suffix = c("_v1", "_v2")) %>%
dplyr::left_join(m_x, by = c("col_id" = "id"), suffix = c("_v1", "_v2"))
# average predictive comparison -------------------------------------------
## input u and other variables v (note: v is v1 irrespective of input u)
u1 <- df_uv %>% dplyr::pull(.data$u1)
u2 <- df_uv %>% dplyr::pull(.data$u2)
df_v1 <- df_uv %>% dplyr::summarize(dplyr::across(dplyr::ends_with("v1")))
## input low
df_uv1 <- dplyr::tibble(u1 = u1, df_v1)
colnames(df_uv1) <- c(u, v)
df_uv1 <- dplyr::tibble("(Intercept)" = 1, df_uv1)
## input high
df_uv2 <- dplyr::tibble(u2 = u2, df_v1)
colnames(df_uv2) <- c(u, v)
df_uv2 <- dplyr::tibble("(Intercept)" = 1, df_uv2)
## get link function from the model object if var_transform "null"
if (is.null(var_transform)) {
model_family <- stats::family(m)
var_transform <- model_family$link
}
if (!any(var_transform %in% c("log", "log10", "logit", "identity"))) {
stop("var_transform must be either log, log10, logit or identity")
}
## get coefficients
if (any(class(m) %in% c("lm", "rlm", "glm"))) {
v_b <- m$coefficients
} else {
v_b <- m@beta
names(v_b) <- v_var_name
}
v_var_id <- match(names(v_b), colnames(df_uv1)) %>%
stats::na.omit() %>%
c()
v_beta <- v_b[names(v_b) %in% c("(Intercept)", u, v)] %>%
data.matrix()
## matrix of input and other variables
m_uv1 <- data.matrix(df_uv1[, v_var_id])
m_uv2 <- data.matrix(df_uv2[, v_var_id])
if (any(rownames(v_beta) != colnames(m_uv1))) {
stop("error in matrix organization")
}
if (any(rownames(v_beta) != colnames(m_uv2))) {
stop("error in matrix organization")
}
v_b
v_beta
m_uv1
usethis::use_mit_license()
usethis::use_roxygen_md()
usethis::use_package_doc()
devtools::document()
devtools::load_all()
devtools::check()
# setup -------------------------------------------------------------------
context("test lm coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test glm ----------------------------------------------------------------
n_sample <- 100
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
mat <- stats::model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample, mean = mat %*% v_b, sd = 1)
m <- lm(y_norm ~ x1 + x2 + x3)
beta <- coef(m)
names(beta) <- NULL
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3")$est,
beta[4])
})
# setup -------------------------------------------------------------------
context("test lm coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test glm ----------------------------------------------------------------
n_sample <- 100
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
mat <- stats::model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample, mean = mat %*% v_b, sd = 1)
m <- lm(y_norm ~ x1 + x2 + x3)
beta <- coef(m)
names(beta) <- NULL
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3a")$est,
beta[4])
})
# setup -------------------------------------------------------------------
context("test lm coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test glm ----------------------------------------------------------------
n_sample <- 100
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
mat <- stats::model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample, mean = mat %*% v_b, sd = 1)
m <- lm(y_norm ~ x1 + x2 + x3)
beta <- coef(m)
names(beta) <- NULL
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3b")$est,
beta[4])
})
# setup -------------------------------------------------------------------
context("test lm coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test glm ----------------------------------------------------------------
n_sample <- 100
n_group <- 10
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
group = gl(n = 10, k = 10)
mat <- model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample,
mean = mat %*% v_b + rnorm(n = n_group)[group],
sd = 1)
m <- lme4::lmer(y_norm ~ x1 + x2 + x3 + (1|group))
beta <- coef(m)
names(beta) <- NULL
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3b")$est,
beta[4])
})
apcomp(m, u = "x1")$est
beta[2]
# setup -------------------------------------------------------------------
context("test lm coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test glm ----------------------------------------------------------------
n_sample <- 100
n_group <- 10
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
group = gl(n = 10, k = 10)
mat <- model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample,
mean = mat %*% v_b + rnorm(n = n_group)[group],
sd = 1)
m <- lme4::lmer(y_norm ~ x1 + x2 + x3 + (1|group))
beta <- m@beta
names(beta) <- NULL
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3b")$est,
beta[4])
})
# setup -------------------------------------------------------------------
context("test lm coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test dataset ------------------------------------------------------------
n_sample <- 100
n_group <- 10
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
group = gl(n = 10, k = 10)
mat <- model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample,
mean = mat %*% v_b + rnorm(n = n_group)[group],
sd = 1)
# run model ---------------------------------------------------------------
m <- lme4::lmer(y_norm ~ x1 + x2 + x3 + (1|group))
beta <- m@beta
names(beta) <- NULL
# test --------------------------------------------------------------------
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3b")$est,
beta[4])
})
# setup -------------------------------------------------------------------
context("test lmer coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test dataset ------------------------------------------------------------
n_sample <- 100
n_group <- 10
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
group = gl(n = 10, k = 10)
mat <- model.matrix(model.frame(~ x1*x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample,
mean = mat %*% v_b + rnorm(n = n_group)[group],
sd = 1)
# run model ---------------------------------------------------------------
m <- lme4::lmer(y_norm ~ x1 + x2 + x3 + (1|group))
beta <- m@beta
names(beta) <- NULL
# test --------------------------------------------------------------------
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3b")$est,
beta[4])
})
# setup -------------------------------------------------------------------
context("test lmer coefficient equivalency")
pacman::p_load(tidyverse, avpc)
ilogit <- function(x) 1 / (1 + exp(-x))
# test dataset ------------------------------------------------------------
n_sample <- 100
n_group <- 10
x1 = rnorm(n = n_sample)
x2 = rnorm(n = n_sample)
x3 = sample(letters[1:5], size = n_sample, replace = TRUE)
group = gl(n = 10, k = 10)
mat <- model.matrix(model.frame(~ x1 + x2 + x3))
v_b <- runif(n = ncol(mat), -1, 1)
y_norm <- rnorm(n = n_sample,
mean = mat %*% v_b + rnorm(n = n_group)[group],
sd = 1)
# run model ---------------------------------------------------------------
m <- lme4::lmer(y_norm ~ x1*x2 + x3 + (1|group))
beta <- m@beta
names(beta) <- NULL
# test --------------------------------------------------------------------
test_that("compare coefficients", {
expect_equal(apcomp(m, u = "x1")$est,
beta[2])
expect_equal(apcomp(m, u = "x2")$est,
beta[3])
expect_equal(apcomp(m, u = "x3b")$est,
beta[4])
})
apcomp(m, u = "x1")
beta[2]
usethis::use_mit_license()
usethis::use_roxygen_md()
usethis::use_package_doc()
devtools::document()
devtools::load_all()
devtools::check()
